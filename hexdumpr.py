#!/usr/bin/python3

"""Script to run the supplied command multiple times, outputing the content
of modified files in cwd, noting where bytes are fixed and where they vary
across runs."""

import argparse
from enum import StrEnum
import io
import os
import shutil
import subprocess
import sys
import time
from typing import Dict, Tuple

from colorama import Fore, Style

VARY: str = "*"
MATCH_FMT = f"{Style.RESET_ALL}{Fore.WHITE}{Style.BRIGHT}"
VARY_FMT = f"{Style.RESET_ALL}{Fore.WHITE}{Style.DIM}"


class Mode(StrEnum):
    HEX = "h"
    BIN = "b"

    def read_file(self, path: str) -> Tuple[int, str]:
        """Reads the supplied file contents in this mode, returning a tuple of length and
        encoded contents."""
        with open(path, "rb") as f:
            bytes = f.read()
        if self == Mode.HEX:
            return len(bytes), bytes.hex()
        else:
            return len(bytes), "".join(f"{b:08b}" for b in bytes)

    def chars_per_byte(self) -> int:
        """Returns the number of characters in read_file output to represent each byte."""
        return 2 if self == Mode.HEX else 8


class FileInfo:
    """A representation of a file content (potentially with wildcards where content varies
    across runs) and length."""

    def __init__(self, mode: Mode, path: str):
        self.path = path
        self.mode = mode
        len, self.content = mode.read_file(self.path)
        self.min_len = len
        self.max_len = len

    def merge_content(self) -> None:
        """Incorporates lentgh and content of path with previous, using a VARY for any characters
        that are not equal."""
        length, content = self.mode.read_file(self.path)
        self.min_len = min(self.min_len, length)
        self.max_len = min(self.max_len, length)
        # Short circuit the identical case.
        if self.content == content:
            return
        # Assemble the merged characted by character.
        with io.StringIO() as out:
            for i in range(min(len(self.content), len(content))):
                if self.content[i] == content[i]:
                    out.write(self.content[i])
                else:
                    out.write(VARY)
            self.content = out.getvalue()

    @staticmethod
    def _columns() -> int:
        """Returns the largest columns as a power of 2 that witll fit in the terminal"""
        try:
            terminal_width = shutil.get_terminal_size().columns
        except OSError:
            terminal_width = 80
        cols = 16
        while cols > 1 and (11 * cols + 8) > terminal_width:
            cols = int(cols / 2)
        return cols

    def print(self) -> None:
        """Prettily print the supplied content to terminal."""
        cols = FileInfo._columns()
        if self.min_len == self.max_len:
            size = f"{self.min_len} bytes"
        else:
            size = f"{self.min_len}-{self.max_len} bytes"

        print(f"\n{Style.BRIGHT}{Fore.GREEN}{self.path}{Fore.WHITE} ({size}){Style.RESET_ALL}\n")
        i = 0
        while True:
            # Start a row
            print(f"{Fore.CYAN}{int(i/self.mode.chars_per_byte()):08}{MATCH_FMT}", end="")
            was_matching = True
            for _ in range(cols):
                # Start a column
                print("  ", end="")
                for ch in range(8):
                    # Baby gap in the middle of a column
                    if ch == 4:
                        print(" ", end="")
                    # Alter the style if we began or stopped matching
                    now_matching = self.content[i] != VARY
                    if now_matching != was_matching:
                        print(MATCH_FMT if now_matching else VARY_FMT, end="")
                        was_matching = now_matching
                    # Print the character.
                    print(self.content[i], end="")
                    i += 1
                    # Bail if we hit the end.
                    if i >= len(self.content):
                        print(f"{Style.RESET_ALL}")
                        return
            # End a row
            print(f"{Style.RESET_ALL}")


def create_parser():
    """Creates the definition of the expected command line flags."""

    def file_if_valid(parser: argparse.ArgumentParser, arg: str) -> str:
        if not os.path.exists(arg):
            parser.error(f"{arg} does not exist")
        return arg

    def mode_if_valid(parser: argparse.ArgumentParser, arg: str) -> Mode:
        mode = getattr(Mode, arg.upper(), None)
        if mode:
            return mode
        try:
            return Mode[arg.lower()]
        except KeyError:
            parser.error(f"{arg} is not a valid Mode")

    parser = argparse.ArgumentParser(
        description="Script to dump contents of a single file or all files generated by a set of "
        "commands, highlighting where data is constant or varies across repeated runs.",
        epilog="Copyright Jody Sankey 2025",
    )
    parser.add_argument(
        "--mode",
        "-m",
        metavar="MODE",
        type=lambda x: mode_if_valid(parser, x),
        default="hex",
        help="The output mode, hex or bin.",
    )
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "--file",
        "-f",
        metavar="FILE",
        type=lambda x: file_if_valid(parser, x),
        help="Single file to dump.",
    )
    group.add_argument(
        "--repeat",
        "-r",
        metavar="COUNT",
        type=int,
        help="Number of times to run the commands specified in remaining args (optionally "
        "separated by &&). The contents of all filed created or modified in CWD will be dumped.",
    )
    parser.add_argument("cmd_args", nargs=argparse.REMAINDER)
    return parser


def collect_commands(cmd_args: list[str]) -> list[list[str]]:
    """Collects the supplied command args into commands separated by '&&'."""
    # Create a list of commands separated by &&
    commands = []
    command = []
    for token in cmd_args:
        if token == "&&":
            commands.append(command)
            command = []
        else:
            command.append(token)
    if command:
        commands.append(command)
    return commands


def run_commands(commands: list[list[str]]) -> None:
    """Runs all commands, raising an exception on any non zero return code."""
    for cmd in commands:
        subprocess.check_call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)


def get_file_state() -> Dict[str, float]:
    """Returns a map of filenames to modtimes in the cwd."""
    return {f.name: f.stat().st_mtime for f in os.scandir() if f.is_file()}


def get_new_and_updated_files(initial: Dict[str, float], updated: Dict[str, float]) -> list[str]:
    """Returns a list of the files that were created or updated between the two supplied states,
    printing information about its findings to the user."""
    new_files = list(updated.keys() - initial.keys())
    if new_files:
        print(f"{Fore.GREEN}New files: {','.join(new_files)}{Style.RESET_ALL}")
    updated_files = [n for n in initial.keys() if n in updated and initial[n] != updated[n]]
    if updated_files:
        print(f"{Fore.GREEN}Updated files: {','.join(updated_files)}{Style.RESET_ALL}")
    return new_files + updated_files


def main() -> None:
    """Runs the script using command line arguments."""

    # Read config from command line arguments.
    args = create_parser().parse_args()

    if args.file:
        # Single file mode
        file_info = FileInfo(args.mode, args.file)
        file_info.print()
        return
    elif args.repeat:
        # Repetition mode
        commands = collect_commands(args.cmd_args)
        initial_state = get_file_state()
        # Gather the changed files after the first run.
        run_commands(commands)
        files = get_new_and_updated_files(initial_state, get_file_state())
        if not files:
            print(f"{Fore.YELLOW}No files created or updated. exiting.{Style.RESET_ALL}")
            sys.exit(0)
        file_infos = {f: FileInfo(args.mode, f) for f in files}
        # Run additional times updating the length range and contents.
        for _ in range(1, args.repeat):
            run_commands(commands)
            for fi in file_infos.values():
                fi.merge_content()
        # Output the results
        for fi in file_infos.values():
            fi.print()


if __name__ == "__main__":
    main()
